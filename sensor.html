<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Motion Detection</title>
  <style>
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      margin: 20px; 
      text-align: center; 
      background-color: #f5f5f5;
      color: #333;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      background: white;
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }
    h1 { 
      font-size: 1.8rem; 
      margin-bottom: 10px;
      color: #2c3e50;
    }
    p {
      color: #7f8c8d;
      margin-bottom: 20px;
    }
    #status { 
      font-size: 1.4rem; 
      margin: 25px 0;
      padding: 15px 25px;
      border-radius: 8px;
      display: inline-block;
      font-weight: bold;
      transition: all 0.3s ease;
    }
    button { 
      margin-top: 15px; 
      padding: 12px 25px; 
      font-size: 1.1rem; 
      background: #3498db;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover {
      background: #2980b9;
    }
    .moving { 
      background-color: rgba(46, 204, 113, 0.2);
      color: #27ae60;
      border: 2px solid #2ecc71;
    }
    .stopped { 
      background-color: rgba(231, 76, 60, 0.2);
      color: #c0392b;
      border: 2px solid #e74c3c;
    }
    .calibrating {
      background-color: rgba(241, 196, 15, 0.2);
      color: #d35400;
      border: 2px solid #f39c12;
    }
    .controls { 
      margin-top: 30px; 
      text-align: left;
      padding: 20px;
      background: #f9f9f9;
      border-radius: 8px;
    }
    .controls label { 
      display: block; 
      margin: 15px 0 8px; 
      font-weight: 500;
    }
    input[type="range"] {
      width: 100%;
      margin-bottom: 15px;
    }
    .value-display {
      font-weight: bold;
      color: #3498db;
    }
    .stats {
      margin-top: 20px;
      font-size: 0.9rem;
      color: #7f8c8d;
    }
    .confidence {
      margin-top: 10px;
      height: 10px;
      background: #ecf0f1;
      border-radius: 5px;
      overflow: hidden;
    }
    .confidence-level {
      height: 100%;
      background: #3498db;
      width: 0%;
      transition: width 0.5s;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Advanced Motion Detection</h1>
    <p>Press the button to allow motion/orientation permissions and start detection.</p>
    <button id="startBtn">Start Detection</button>
    <div id="status">Waiting for input...</div>

    <div class="confidence">
      <div id="confidenceLevel" class="confidence-level"></div>
    </div>
    <div id="confidenceValue" class="stats">Confidence: 0%</div>

    <div class="controls">
      <label for="threshold">Motion Sensitivity (Threshold: <span id="thresholdValue" class="value-display">0.15</span>)</label>
      <input type="range" id="threshold" min="0.05" max="0.5" step="0.01" value="0.15">

      <label for="bufferSize">Buffer Size (Readings: <span id="bufferValue" class="value-display">10</span>)</label>
      <input type="range" id="bufferSize" min="5" max="30" step="1" value="10">

      <label for="stabilityThreshold">Stability Threshold (<span id="stabilityValue" class="value-display">0.08</span>)</label>
      <input type="range" id="stabilityThreshold" min="0.02" max="0.2" step="0.01" value="0.08">
    </div>

    <div id="stats" class="stats">
      Current acceleration: 0.00 g<br>
      Filtered value: 0.00 g<br>
      Steps detected: 0
    </div>
  </div>

  <script>
    const statusEl = document.getElementById("status");
    const thresholdSlider = document.getElementById("threshold");
    const bufferSlider = document.getElementById("bufferSize");
    const stabilitySlider = document.getElementById("stabilityThreshold");
    const thresholdValueEl = document.getElementById("thresholdValue");
    const bufferValueEl = document.getElementById("bufferValue");
    const stabilityValueEl = document.getElementById("stabilityValue");
    const statsEl = document.getElementById("stats");
    const confidenceLevelEl = document.getElementById("confidenceLevel");
    const confidenceValueEl = document.getElementById("confidenceValue");

    // Configuration with improved default values
    let threshold = parseFloat(thresholdSlider.value);
    let bufferSize = parseInt(bufferSlider.value);
    let stabilityThreshold = parseFloat(stabilitySlider.value);
    let isCalibrating = false;
    let calibrationSamples = 0;
    let baselineNoiseLevel = 0.05; // Will be calibrated

    // Update slider value displays
    thresholdSlider.addEventListener("input", () => {
      threshold = parseFloat(thresholdSlider.value);
      thresholdValueEl.textContent = threshold.toFixed(2);
    });

    bufferSlider.addEventListener("input", () => {
      bufferSize = parseInt(bufferSlider.value);
      bufferValueEl.textContent = bufferSize;
    });

    stabilitySlider.addEventListener("input", () => {
      stabilityThreshold = parseFloat(stabilitySlider.value);
      stabilityValueEl.textContent = stabilityThreshold.toFixed(2);
    });

    function updateStatus(state, confidence) {
      if (state === "moving") {
        statusEl.textContent = "ðŸš¶ Person is Moving";
        statusEl.className = "moving";
      } else if (state === "stopped") {
        statusEl.textContent = "ðŸ›‘ Person is Stopped";
        statusEl.className = "stopped";
      } else {
        statusEl.textContent = "ðŸ”§ Calibrating... Hold still";
        statusEl.className = "calibrating";
      }
      
      // Update confidence indicator
      const confidencePercent = Math.round(confidence * 100);
      confidenceLevelEl.style.width = `${confidencePercent}%`;
      confidenceValueEl.textContent = `Confidence: ${confidencePercent}%`;
    }

    function updateStats(currentAccel, filteredAccel, steps) {
      statsEl.innerHTML = `
        Current acceleration: ${currentAccel.toFixed(2)} g<br>
        Filtered value: ${filteredAccel.toFixed(2)} g<br>
        Steps detected: ${steps}
      `;
    }

    function startDetection() {
      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission().then(response => {
          if (response === 'granted') {
            initMotionDetection();
          } else {
            alert('Permission denied for motion sensors');
          }
        });
      } else {
        initMotionDetection();
      }
    }

    // Motion detection variables
    let lastAcceleration = { x: 0, y: 0, z: 0 };
    let accelerationBuffer = [];
    let stepCount = 0;
    let lastStepTime = 0;
    let movementState = "unknown";
    let movementConfidence = 0;
    let filteredAcceleration = 0;
    
    // For step detection
    let stepHistory = [];
    let lastPeakTime = 0;
    let peakThreshold = 0.2;
    let valleyThreshold = -0.1;
    let wasAbove = false;

    function initMotionDetection() {
      // Start calibration
      isCalibrating = true;
      calibrationSamples = 0;
      baselineNoiseLevel = 0.05;
      accelerationBuffer = [];
      updateStatus("calibrating", 0);
      
      window.addEventListener('devicemotion', motionHandler);
    }

    function lowPassFilter(newValue, oldValue, alpha) {
      return alpha * newValue + (1 - alpha) * oldValue;
    }

    function calculateMagnitude(accel) {
      return Math.sqrt(
        accel.x * accel.x + 
        accel.y * accel.y + 
        accel.z * accel.z
      );
    }

    function motionHandler(event) {
      if (!event.accelerationIncludingGravity) return;
      
      const accel = event.accelerationIncludingGravity;
      const currentMagnitude = calculateMagnitude(accel);
      
      // Apply low-pass filter to smooth the data
      filteredAcceleration = lowPassFilter(currentMagnitude, filteredAcceleration, 0.2);
      
      // Store in buffer for analysis
      accelerationBuffer.push(filteredAcceleration);
      if (accelerationBuffer.length > bufferSize) {
        accelerationBuffer.shift();
      }
      
      // Calculate variance in the buffer
      const mean = accelerationBuffer.reduce((a, b) => a + b, 0) / accelerationBuffer.length;
      const variance = accelerationBuffer.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / accelerationBuffer.length;
      
      // Calibration phase - first 50 samples
      if (isCalibrating) {
        calibrationSamples++;
        
        if (calibrationSamples < 50) {
          // Still calibrating
          const progress = Math.min(1, calibrationSamples / 50);
          updateStatus("calibrating", progress);
        } else {
          // Finish calibration
          isCalibrating = false;
          baselineNoiseLevel = Math.max(0.02, variance * 1.5);
          updateStatus("stopped", 0.5);
        }
        
        lastAcceleration = { x: accel.x, y: accel.y, z: accel.z };
        updateStats(currentMagnitude, filteredAcceleration, stepCount);
        return;
      }
      
      // Step detection algorithm (for walking)
      const delta = filteredAcceleration - mean;
      
      if (delta > peakThreshold && !wasAbove) {
        // Detect potential step (peak)
        const now = Date.now();
        if (now - lastPeakTime > 300) { // Minimum 300ms between steps
          stepCount++;
          lastPeakTime = now;
          stepHistory.push(now);
          
          // Keep only steps from last 10 seconds
          stepHistory = stepHistory.filter(time => now - time < 10000);
        }
        wasAbove = true;
      } else if (delta < valleyThreshold && wasAbove) {
        wasAbove = false;
      }
      
      // Determine movement state with confidence
      const stepsPerMinute = stepHistory.length * 6; // Steps in last 10 seconds * 6
      const isLikelyWalking = stepsPerMinute > 60 && stepsPerMinute < 180;
      
      if (variance > threshold) {
        // Significant movement detected
        if (movementState !== "moving") {
          movementState = "moving";
          movementConfidence = 0.5;
        } else {
          movementConfidence = Math.min(1, movementConfidence + 0.1);
        }
        
        // Boost confidence if we detect walking pattern
        if (isLikelyWalking) {
          movementConfidence = Math.min(1, movementConfidence + 0.2);
        }
      } else if (variance < stabilityThreshold) {
        // Very stable reading - likely stopped
        if (movementState !== "stopped") {
          movementState = "stopped";
          movementConfidence = 0.5;
        } else {
          movementConfidence = Math.min(1, movementConfidence + 0.1);
        }
        
        // Reduce confidence if we detect steps
        if (isLikelyWalking) {
          movementConfidence = Math.max(0.1, movementConfidence - 0.3);
        }
      } else {
        // Intermediate state - reduce confidence gradually
        movementConfidence = Math.max(0, movementConfidence - 0.05);
      }
      
      // Update UI
      updateStatus(movementState, movementConfidence);
      updateStats(currentMagnitude, filteredAcceleration, stepCount);
      
      lastAcceleration = { x: accel.x, y: accel.y, z: accel.z };
    }

    document.getElementById("startBtn").addEventListener("click", startDetection);
  </script>
</body>
</html>
